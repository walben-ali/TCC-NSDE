<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Numerical Solutions of Differential Equations – Appendix J — Numerical Solutions of Non-Linear Equations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Z_App_Eigen.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Z_App_Basic.html">Appendices</a></li><li class="breadcrumb-item"><a href="./Z_App_Root.html"><span class="chapter-number">J</span>&nbsp; <span class="chapter-title">Numerical Solutions of Non-Linear Equations</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Numerical Solutions of Differential Equations</a> 
        <div class="sidebar-tools-main">
    <div class="dropdown">
      <a href="" title="Download" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Download"><i class="bi bi-download"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="./Numerical-Solutions-of-Differential-Equations.pdf">
              <i class="bi bi-file-pdf pe-1"></i>
            Download PDF
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="./Numerical-Solutions-of-Differential-Equations.docx">
              <i class="bi bi-file-word pe-1"></i>
            Download Docx
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="./Numerical-Solutions-of-Differential-Equations.epub">
              <i class="bi bi-journal pe-1"></i>
            Download ePub
            </a>
          </li>
      </ul>
    </div>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_Internal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Internal Workings of MATLAB</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./Part_LinAlg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Linear Algebra</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_LinAlg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Solving Linear Systems of Equations</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./Part_IVPs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Solving Initial Value Problems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_IVP_Euler.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">The Euler Method</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_IVP_ModEuler.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">The Modified Euler Method</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_IVP_RK4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Fourth Order Runge-Kutta Method</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_IVP_InBuilt.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">MATLAB’s In-Built Procedures</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07_IVP_Implicit.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Implicit IVP Solvers</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./Part_BVPs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Solving Boundary Value Problems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08_BVP.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Boundary Value Problems</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09_MVP.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Mixed Value Problems</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10_SBVP.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Symmetric Boundary Conditions</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./Part_PDEs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Solving Partial Differential Equations</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11_PDE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Heat Equation</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Z_App_Basic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">MATLAB Basics</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Z_App_Arrays.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Arrays in MATLAB</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Z_App_Loops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Loops</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Z_App_Plot.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Plotting in MATLAB</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Z_App_ReadWrite.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Reading &amp; Writing Data</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Z_App_GE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">Gaussian Elimination Method</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Z_App_MatDeco.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">G</span>&nbsp; <span class="chapter-title">Matrix Decompositions</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Z_App_DataFit.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">H</span>&nbsp; <span class="chapter-title">Data Fitting</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Z_App_Eigen.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">I</span>&nbsp; <span class="chapter-title">Eigenvalue Problems</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Z_App_Root.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">J</span>&nbsp; <span class="chapter-title">Numerical Solutions of Non-Linear Equations</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#one-dimensional-root-finding-algorithm" id="toc-one-dimensional-root-finding-algorithm" class="nav-link active" data-scroll-target="#one-dimensional-root-finding-algorithm"><span class="header-section-number">J.1</span> One-Dimensional Root-Finding Algorithm</a></li>
  <li><a href="#bisection-method" id="toc-bisection-method" class="nav-link" data-scroll-target="#bisection-method"><span class="header-section-number">J.2</span> Bisection Method</a></li>
  <li><a href="#secant-method" id="toc-secant-method" class="nav-link" data-scroll-target="#secant-method"><span class="header-section-number">J.3</span> Secant Method</a></li>
  <li><a href="#newton-raphson-method-nr" id="toc-newton-raphson-method-nr" class="nav-link" data-scroll-target="#newton-raphson-method-nr"><span class="header-section-number">J.4</span> Newton-Raphson Method (NR)</a></li>
  <li><a href="#solving-systems-of-non-linear-equations-numerically" id="toc-solving-systems-of-non-linear-equations-numerically" class="nav-link" data-scroll-target="#solving-systems-of-non-linear-equations-numerically"><span class="header-section-number">J.5</span> Solving Systems of Non-Linear Equations Numerically</a></li>
  <li><a href="#minimisation-problems" id="toc-minimisation-problems" class="nav-link" data-scroll-target="#minimisation-problems"><span class="header-section-number">J.6</span> Minimisation Problems</a></li>
  <li><a href="#method-of-steepest-descent" id="toc-method-of-steepest-descent" class="nav-link" data-scroll-target="#method-of-steepest-descent"><span class="header-section-number">J.7</span> Method of Steepest Descent</a></li>
  <li><a href="#variants-of-the-newton-raphson-method" id="toc-variants-of-the-newton-raphson-method" class="nav-link" data-scroll-target="#variants-of-the-newton-raphson-method"><span class="header-section-number">J.8</span> Variants of the Newton-Raphson Method</a></li>
  <li><a href="#applications-of-minimisation-methods" id="toc-applications-of-minimisation-methods" class="nav-link" data-scroll-target="#applications-of-minimisation-methods"><span class="header-section-number">J.9</span> Applications of Minimisation Methods</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Z_App_Basic.html">Appendices</a></li><li class="breadcrumb-item"><a href="./Z_App_Root.html"><span class="chapter-number">J</span>&nbsp; <span class="chapter-title">Numerical Solutions of Non-Linear Equations</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Appendix J — Numerical Solutions of Non-Linear Equations</h1>
</div>



<div class="quarto-title-meta column-body">

    
  
    
  </div>
  


</header>


<p>An important task in numerical analysis is that of finding the root <span class="math inline">\(x\)</span> of a function <span class="math inline">\(f:\mathbb{R}\to \mathbb{R}\)</span>, i.e.&nbsp;finding the point(s) <span class="math inline">\(x\in \mathbb{R}\)</span> such that <span class="math inline">\(f(x)=0\)</span> (equivalently, in higher-dimensions, the root of a function <span class="math inline">\(\boldsymbol{f}:\mathbb{R}^M \to \mathbb{R}^N\)</span> is a vector/point <span class="math inline">\(\boldsymbol{x} \in \mathbb{R}^M\)</span> such that <span class="math inline">\(\boldsymbol{f}(\boldsymbol{x})=\boldsymbol{0}\)</span>). It is important to realise that for many real-life industrial problems (such as the discretisations of domains for partial differential equations), the system be very large, having a system of <span class="math inline">\(10000\)</span> parameters or even higher is not uncommon.</p>
<p>Throughout this section, the exact roots of non-linear functions will be denoted <span class="math inline">\(x^{\ast}\)</span> or <span class="math inline">\(\boldsymbol{x}^{\ast}\)</span>. Numerical algorithms for the approximation of <span class="math inline">\(x^{\ast}\)</span> or <span class="math inline">\(\boldsymbol{x}^{\ast}\)</span> are usually iterative and the aim is to generate a sequence of values <span class="math inline">\(x_k\)</span> or <span class="math inline">\(\boldsymbol{x}_k\)</span> such that <span class="math display">\[ \lim_{k\to \infty } x_k = x^\ast \quad \text{or} \quad \lim_{k\to \infty } \boldsymbol{x}_k = \boldsymbol{x}^\ast.\]</span></p>
<section id="one-dimensional-root-finding-algorithm" class="level2" data-number="J.1">
<h2 data-number="J.1" class="anchored" data-anchor-id="one-dimensional-root-finding-algorithm"><span class="header-section-number">J.1</span> One-Dimensional Root-Finding Algorithm</h2>
<p>In general, a non-linear function may have several roots and to find a root, an algorithm would require an <em>initial guess</em> <span class="math inline">\(x_0\)</span> which guides the solution procedure. Finding such a guess is usually difficult and requires some <em>a priori</em> knowledge.</p>
<p>Any method for solving a problem of the form <span class="math inline">\(f(x) = 0\)</span> (or indeed <span class="math inline">\(\boldsymbol{f}(\boldsymbol{x})= \boldsymbol{0}\)</span>) should have the following properties:</p>
<ol type="1">
<li>It should be “easy” to use, preferably using only information on <span class="math inline">\(f\)</span>, not on its derivatives;</li>
<li>It should be fast and be able to find a root to a specified tolerance. More specifically, a sequence <span class="math inline">\(\{x_k\}_{k \in \mathbb{N}}\)</span> generated by a numerical method is said to converge to <span class="math inline">\(x^\ast\)</span> with <em>order <span class="math inline">\(p\)</span></em> if there exists a constant <span class="math inline">\(C&gt;0\)</span> such that for a large enough <span class="math inline">\(k_0 \in \mathbb{N}\)</span>, <span class="math display">\[\frac{|x_{k+1} - x^{\ast} |}{|x_{k} - x^{\ast} |^p} \leq C \quad \text{for all} \quad k \geq k_0.\]</span></li>
<li>It should be reliable, i.e.&nbsp;it should converge to a root close to an initial guess and not diverge or become chaotic. The convergence of iterative methods for root-finding of a non-linear equation depends, in general, on the initial guess <span class="math inline">\(x_0\)</span>. The method is called:</li>
</ol>
<ul>
<li><em>Locally Convergent</em> if the convergence holds for any starting guess <span class="math inline">\(x_0\)</span> that belongs to a suitable neighbourhood of the root <span class="math inline">\(x^\ast\)</span>;</li>
<li><em>Globally Convergent</em> if the convergence holds for any choice of <span class="math inline">\(x_0\)</span>.</li>
</ul>
<p>There is no ideal method, so more practical algorithms use a combination of methods to find the roots.</p>
</section>
<section id="bisection-method" class="level2" data-number="J.2">
<h2 data-number="J.2" class="anchored" data-anchor-id="bisection-method"><span class="header-section-number">J.2</span> Bisection Method</h2>
<p>For <span class="math inline">\(k \geq 0\)</span>:</p>
<ol type="1">
<li>Find an interval <span class="math inline">\([a_k,b_k]\)</span> over which <span class="math inline">\(f\)</span> changes sign (i.e.&nbsp;<span class="math inline">\(f(a_k)&lt;0&lt;f(b_k)\)</span> or <span class="math inline">\(f(a_k)&gt;0&gt;f(b_k)\)</span>) and set <span class="math inline">\(c_k=\frac{a_k+b_k}{2}\)</span> and define <span class="math inline">\(x_{k+1}=c_k\)</span>;</li>
<li>The function <span class="math inline">\(f\)</span> must change sign over one of the two intervals <span class="math inline">\([a_k,c_k]\)</span> or <span class="math inline">\([c_k,b_k]\)</span>;</li>
<li><ol type="i">
<li>If <span class="math inline">\(f\)</span> changes sign in the interval <span class="math inline">\([a_k,c_k]\)</span>, then let <span class="math inline">\(a_{k+1}=a_k\)</span> and <span class="math inline">\(b_{k+1}=c_{k}\)</span>;</li>
<li>If <span class="math inline">\(f\)</span> changes sign in the interval <span class="math inline">\([c_k,b_k]\)</span>, then let <span class="math inline">\(a_{k+1}=c_k\)</span> and <span class="math inline">\(b_{k+1}=b_{k}\)</span>;</li>
</ol></li>
<li>Update <span class="math inline">\(k \to k+1\)</span> and repeat steps 1-3 until <span class="math inline">\(|b_{k}-a_{k}|&lt;\tau\)</span> for some tolerance <span class="math inline">\(\tau\)</span>;</li>
<li>The sequence of values <span class="math inline">\(\left\{ x_k \right\}\)</span> will converge to the exact root <span class="math inline">\(x^{\ast}.\)</span></li>
</ol>
<p>Advantages of the Bisection method:</p>
<ul>
<li>No information about the derivative of <span class="math inline">\(f\)</span> is needed.</li>
<li>For the right choices of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, convergence is guaranteed, making it very reliable.</li>
<li>The more iterations there are, the more accurate the solution will be (not susceptible to numerical errors).</li>
<li>Iterations are easy to do since they require finding the average only.</li>
</ul>
<p>Disadvantages of the Bisection method:</p>
<ul>
<li>The convergence is very slow, linear at best. This means that if <span class="math inline">\(x_k\)</span> is an estimate for the exact root <span class="math inline">\(x^{\ast}\)</span> of <span class="math inline">\(f\)</span> and <span class="math inline">\(e_k=x^{\ast}-x_k\)</span> is the error, then if <span class="math inline">\(e_k\)</span> is small, the error at the next iteration will be <span class="math inline">\(|e_{k+1} | \approx K |e_k|\)</span> where <span class="math inline">\(K \in (0,1)\)</span> is a constant (usually for the bisection method <span class="math inline">\(K=0.5\)</span>).</li>
<li>Two initial guesses are needed (the values of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>) in order to specify the bracketing interval, additionally, the function must change sign over this interval.</li>
<li>The function has to be real and continuous.</li>
<li>Relies on sign changes, meaning it cannot find repeated roots (like the root of <span class="math inline">\(f(x)=x^2\)</span>).</li>
<li>The method does not work for systems of equations.</li>
<li>The roots have to be reasonably far away from another another in order to ensure convergence to one root or the other.</li>
</ul>
</section>
<section id="secant-method" class="level2" data-number="J.3">
<h2 data-number="J.3" class="anchored" data-anchor-id="secant-method"><span class="header-section-number">J.3</span> Secant Method</h2>
<p>For <span class="math inline">\(k \geq 0\)</span>:</p>
<ol type="1">
<li>Consider the value of <span class="math inline">\(f\)</span> at the two points <span class="math inline">\(x_k\)</span> and <span class="math inline">\(x_{k+1}\)</span>;</li>
<li>Draw a straight line through the two points <span class="math inline">\(\left( x_k, f(x_k) \right)\)</span> and <span class="math inline">\(\left( x_{k+1}, f(x_{k+1}) \right)\)</span>;</li>
<li>This line has a root at <span class="math display">\[x_{k+2} = \frac{x_{k} f(x_{k+1}) - x_{k+1} f(x_k)}{f(x_{k+1}) - f(x_k)};\]</span></li>
<li>Update <span class="math inline">\(k \to k+1\)</span> and repeat steps 1-3 for the points <span class="math inline">\(x_{k+1}\)</span> and <span class="math inline">\(x_{k+2}\)</span>;</li>
<li>Continue to produce a set of approximations <span class="math inline">\(x_k\)</span> to the root <span class="math inline">\(x^{\ast}\)</span> until either <span class="math display">\[|f(x_k)|&lt; \tau \quad \text{or} \quad |x_{k+1}-x_k| &lt; \tau\]</span> where <span class="math inline">\(\tau\)</span> is some specified tolerance.</li>
</ol>
<p>Advantages of the Secant method:</p>
<ul>
<li>No information about the derivative of <span class="math inline">\(f\)</span> is needed.</li>
<li>Converges <em>super-linearly</em> fashion, i.e.&nbsp;if <span class="math inline">\(e_k=x^{\ast}-x_k\)</span>, then <span class="math inline">\(|e_{k+1}| \approx K |e_k|^{\varphi}\)</span> where <span class="math inline">\(K \in (0,1)\)</span> and <span class="math inline">\(\varphi\)</span> is the golden ratio.</li>
<li>Requires only one function evaluation per iteration, making it computationally inexpensive.</li>
</ul>
<p>Disadvantages of the Secant Method:</p>
<ul>
<li>It may not always converge if the initial values are not close enough to the root.</li>
<li>The method may not converge if the root is near a turning point (i.e.&nbsp;if the function is differentiable and there is a point in <span class="math inline">\(\xi \in [x_0,x_1]\)</span> such that <span class="math inline">\(f(\xi)=0\)</span>, then the method may not converge).</li>
<li>There is no guaranteed error bound.</li>
</ul>
</section>
<section id="newton-raphson-method-nr" class="level2" data-number="J.4">
<h2 data-number="J.4" class="anchored" data-anchor-id="newton-raphson-method-nr"><span class="header-section-number">J.4</span> Newton-Raphson Method (NR)</h2>
<p>For <span class="math inline">\(k \geq 0\)</span>:</p>
<ol type="1">
<li>Evaluate <span class="math inline">\(f(x)\)</span> and <span class="math inline">\(f'(x)\)</span> at <span class="math inline">\(x_k\)</span>;</li>
<li>Approximate <span class="math inline">\(f\)</span> by a line of slope <span class="math inline">\(f'(x_k)\)</span> through the point <span class="math inline">\((x_k, f(x_k))\)</span>;</li>
<li>This line has a root at <span class="math display">\[x_{k+1}=x_k-\frac{f(x_k)}{f'(x_k)};\]</span></li>
<li>Update <span class="math inline">\(k \to k+1\)</span> and repeat steps 1-3 until either <span class="math display">\[|f(x_k)|&lt; \tau \quad \text{or} \quad \quad |x_{k+1}-x_k| &lt; \tau.\]</span></li>
</ol>
<p>Advantages of the NR:</p>
<ul>
<li>The method is quadratically convergent, i.e.&nbsp;if <span class="math inline">\(e_k=x^{\ast}-x_k\)</span>, then <span class="math inline">\(|e_{k+1}| \approx K |e_k|^2\)</span>.</li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>To show this rate of convergence, consider the expression for the iteration: <span class="math display">\[\begin{align*}
&amp; x_{k+1}=x_k-\frac{f(x_k)}{f'(x_k)} \\
\quad \underset{-x^{\ast}}{\Rightarrow} \quad &amp; x_{k+1}-x^{\ast}=x_k-x^{\ast}-\frac{f(x_k)}{f'(x_k)} \\
\quad \underset{\times -1}{\Rightarrow} \quad &amp; x^{\ast}-x_{k+1}=x^{\ast}-x_k+\frac{f(x_k)}{f'(x_k)} \\
\quad \underset{f\left( x^{\ast} \right)=0}{\Rightarrow} \quad &amp; x^{\ast}-x_{k+1}=x^{\ast}-x_k+\frac{f(x_k)-f\left( x^{\ast} \right)}{f'(x_k)} \\
\implies \quad &amp; x^{\ast}-x_{k+1}=\frac{1}{f'(x_k)} \left[ f(x_k)+f'(x_k)\left( x^{\ast}-x_k \right)-f\left( x^{\ast} \right) \right]. \\
\end{align*}\]</span></p>
<p>Recall that by Taylor’s Theorem<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, the term in the square brackets can be written as <span class="math display">\[\left[ f(x_k)+f'(x_k)(x^{\ast}-x_k)-f(x^{\ast}) \right]=-\frac{1}{2} f"(\xi) (x^\ast - x_k)^2\]</span> where <span class="math inline">\(\xi\)</span> is a point between <span class="math inline">\(x_k\)</span> and <span class="math inline">\(x^{\ast}\)</span>. Therefore <span class="math display">\[\begin{align*}
|e_{k+1}|=|x^{\ast}-x_{k+1}|&amp; =\left| \frac{1}{f'(x_k)} \left[ f(x_k)+f'(x_k)\left( x^{\ast}-x_k \right)-f\left( x^{\ast} \right) \right] \right| \\
&amp; \leq \left| \frac{1}{f'(x_k)} \left[ -\frac{1}{2} f''(\xi) (x^\ast - x_k)^2 \right] \right| \\
&amp; = \frac{1}{2} \left|\frac{f''(\xi)}{f'(x_k)} \right| |e_n|^2.
\end{align*}\]</span> Therefore the NR converges quadratically. Obviously, some analysis is needed to make this statement precise, but roughly speaking it shows that provided <span class="math inline">\(f, f'\)</span> and <span class="math inline">\(f"\)</span> are continuous near <span class="math inline">\(x^\ast\)</span>, <span class="math inline">\(f'(x^\ast) \neq 0\)</span> and <span class="math inline">\(x_0\)</span> is close enough to <span class="math inline">\(x^{\ast}\)</span>, then Newton’s method converges quadratically.</p>
</div>
</div>
<ul>
<li>The method converges locally very quickly.</li>
<li>Can be generalised to higher dimensions and to sets of equations.</li>
</ul>
<p>Disadvantages of the NR:</p>
<ul>
<li>The function has to be differentiable, meaning it might be difficult to implement if the function was obtained from a set of measurements.</li>
<li>The initial value has to be reasonably close to the root, otherwise the method will not converge.</li>
<li>If the gradient at the initial point is 0 or close to 0, then the method will not converge.</li>
</ul>
<p>Note that the NR is a generalisation of the Secant method. Indeed, the general iteration step for the secant method is <span class="math display">\[x_{k+1} = \frac{x_{k-1} f(x_k) - x_k f(x_{k-1})}{f(x_k) -
f(x_{k-1})}.\]</span> The right hand side can be rearranged to give <span id="eq-sec"><span class="math display">\[x_{k+1}=x_k-\frac{x_{k}- x_{k-1}}{f(x_k)-f(x_{k-1})} f(x_k) \tag{J.1}\]</span></span> which is a simple approximation to the iteration <span id="eq-new"><span class="math display">\[x_{k+1}=x_k-\frac{1}{f'(x_k)}f(x_k) \tag{J.2}\]</span></span> which is well-known as NR. The Secant method <a href="#eq-sec" class="quarto-xref">Equation&nbsp;<span>J.1</span></a> is therefore an approximate version of NR which makes use of evaluations of the function <span class="math inline">\(f\)</span> and does not require evaluations of the derivative of <span class="math inline">\(f\)</span>. The disadvantage of the Secant method is that it converges more slowly than NR (although both methods are faster than linear).</p>
<p>Python has an in-built root-finding algorithm called <em>Brent’s Method</em> (from Brent, R. P., Algorithms for Minimization Without Derivatives. Englewood Cliffs, NJ: Prentice-Hall, 1973. Ch. 3-4.), also sometimes referred to as the <em>van Wijngaarden-Dekker-Brent Method</em>. This is a more reliable version of the Secant method since it uses a combination of inverse quadratic extrapolation, root bracketing, interval bisection and inverse quadratic interpolation.</p>
</section>
<section id="solving-systems-of-non-linear-equations-numerically" class="level2" data-number="J.5">
<h2 data-number="J.5" class="anchored" data-anchor-id="solving-systems-of-non-linear-equations-numerically"><span class="header-section-number">J.5</span> Solving Systems of Non-Linear Equations Numerically</h2>
<p>Methods for solving non-linear systems of equations can be derived as generalisations of the scalar case. Consider the system of equations given by <span class="math inline">\(\boldsymbol{f}(\boldsymbol{x}) = \boldsymbol{0}\)</span> where <span class="math inline">\(\boldsymbol{f} : \mathbb{R}^N \to \mathbb{R}^N\)</span> is a given vector-valued function of the <span class="math inline">\(N\)</span> variables <span class="math inline">\(x_1,x_2 \dots,x_N\)</span>.</p>
<p>For example, if the function <span class="math inline">\(\boldsymbol{f}\)</span> is given by <span class="math display">\[\boldsymbol{f}(\boldsymbol{x})=\begin{pmatrix} x_1^2+x_2^2-1 \\ x_1-x_2 \end{pmatrix},\]</span> then the root-finding algorithm would need to find <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span> such that <span class="math display">\[x_1^2 + x_2^2 -1 = 0 \quad \text{and} \quad x_1 - x_2 = 0.\]</span> In this case, the first equation is a unit circle and the second is a straight line. Therefore the solution is where the circle and the line intersect, and it can easily be seen that the solutions are <span class="math inline">\(\pm \left( \frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}\right)\)</span>.</p>
<p>To write down NR for a system <span class="math inline">\(\boldsymbol{f}(\boldsymbol{x})=\boldsymbol{0}\)</span>, first write down the “obvious” generalisation of the scalar case <a href="#eq-new" class="quarto-xref">Equation&nbsp;<span>J.2</span></a>, i.e.&nbsp; <span id="eq-newsys"><span class="math display">\[\boldsymbol{x}_{n+1} = \boldsymbol{x}_n - J(\boldsymbol{x}_{n})^{-1} \boldsymbol{f}(\boldsymbol{x}_n) \tag{J.3}\]</span></span> where the role of the reciprocal of the derivative of <span class="math inline">\(\boldsymbol{f}\)</span> is replaced by the inverse of the Jacobian matrix <span class="math inline">\(J(\boldsymbol{x})\)</span> which is given by <span class="math display">\[J(\boldsymbol{x})=\begin{pmatrix} \frac{\partial f_1}{\partial x_1} &amp; \frac{\partial f_1}{\partial x_2} \\ \frac{\partial f_2}{\partial x_1} &amp; \frac{\partial f_2}{\partial x_2} \end{pmatrix}\]</span> (where <span class="math inline">\(f_i\)</span> is the <span class="math inline">\({i}^{\mathrm{th}}\)</span> component of <span class="math inline">\(\boldsymbol{f}\)</span> for <span class="math inline">\(i=1,2\)</span>). More generally for a function <span class="math inline">\(\boldsymbol{f}: \mathbb{R}^N \to \mathbb{R}^N\)</span>, the Jacobian is given by <span class="math display">\[J(\boldsymbol{x})=\begin{pmatrix} \frac{\partial f_1}{\partial x_1} &amp; \frac{\partial f_1}{\partial x_2} &amp; \dots &amp; \frac{\partial f_1}{\partial x_N} \\ \frac{\partial f_2}{\partial x_1} &amp; \frac{\partial f_2}{\partial x_2} &amp; \dots &amp; \frac{\partial f_2}{\partial x_N} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ \frac{\partial f_N}{\partial x_1} &amp; \frac{\partial f_N}{\partial x_2} &amp; \dots &amp; \frac{\partial f_N}{\partial x_N} \end{pmatrix}(\boldsymbol{x})\]</span> where <span class="math inline">\(f_i\)</span> is the <span class="math inline">\({i}^{\mathrm{th}}\)</span> component of <span class="math inline">\(\boldsymbol{f}\)</span> for <span class="math inline">\(i=1,2,\dots,N\)</span>. This can be written in element form as <span class="math display">\[J(\boldsymbol{x})_{ij}=\frac{\partial f_i}{\partial x_j}(\boldsymbol{x}) \quad \text{for all} \quad i,j = 1,2,\dots,N.\]</span></p>
<p>More realistically, Equation <a href="#eq-newsys" class="quarto-xref">Equation&nbsp;<span>J.3</span></a> should be written as <span class="math inline">\(\boldsymbol{x}_{k+1} = \boldsymbol{x}_k + \boldsymbol{d}_k\)</span> where the Newton correction <span class="math inline">\(\boldsymbol{d}_k\)</span> is a vector that can be computed by solving the system of <span class="math inline">\(N\)</span> linear equations <span class="math inline">\(J(\boldsymbol{x}_k) \boldsymbol{d}_k = - \boldsymbol{f}(\boldsymbol{x}_k)\)</span>. This means that each step of NR requires the solution of an <span class="math inline">\(N\)</span>-dimensional linear system where the matrix <span class="math inline">\(J(\boldsymbol{x})\)</span> and right hand side <span class="math inline">\(\boldsymbol{f}(\boldsymbol{x}_k)\)</span> have to be recomputed at every step (note that the inverse of the Jacobian is not normally computed since it is not needed, all that is needed is the solution of a single linear system with coefficient matrix <span class="math inline">\(J(\boldsymbol{x}_k)\)</span>, which can be done without actually computing the inverse of <span class="math inline">\(J(\boldsymbol{x}_k)\)</span>).</p>
</section>
<section id="minimisation-problems" class="level2" data-number="J.6">
<h2 data-number="J.6" class="anchored" data-anchor-id="minimisation-problems"><span class="header-section-number">J.6</span> Minimisation Problems</h2>
<p>Closely related to the idea of root-finding is the question of minimising a function <span class="math inline">\(g : \mathbb{R}^N \to \mathbb{R}\)</span>. Such a problem can take one of two forms:</p>
<ol type="1">
<li><em>Unconstrained</em> optimisation which minimises <span class="math inline">\(g(\boldsymbol{x})\)</span>;</li>
<li><em>Constrained</em> optimisation minimises <span class="math inline">\(g(\boldsymbol{x})\)</span> with an additional condition. For example, the value of <span class="math inline">\(\boldsymbol{x}\)</span> needs to be found such that the function <span class="math inline">\(g\)</span> attains its minimum provided that <span class="math inline">\(h(\boldsymbol{x})=0\)</span> or <span class="math inline">\(h(\boldsymbol{x})\geq 0\)</span>.</li>
</ol>
<p>An example of a constrained minimisation problem could be to minimise the cost of producing a product in a factory subject to keeping the pollution caused in this production as low as possible.</p>
<p>There are two kinds of minimum points, <em>global} and </em>local}: Given a function <span class="math inline">\(g : \mathbb{R}^N \to \mathbb{R}\)</span></p>
<ul>
<li>A <em>global</em> minimum is a point <span class="math inline">\(\boldsymbol{x}^{\ast}\)</span> such that <span class="math inline">\(g(\boldsymbol{x}^{\ast}) \leq g(\boldsymbol{x})\)</span> for all <span class="math inline">\(\boldsymbol{x} \in \mathbb{R}^N\)</span>, i.e. <span class="math display">\[g(\boldsymbol{x}^\ast) = \min_{\boldsymbol{x} \in \mathbb{R}^N} g(\boldsymbol{x}).\]</span></li>
<li>A <em>local</em> minimum is a point <span class="math inline">\(\boldsymbol{x}^{\ast}\)</span> such that <span class="math inline">\(g(\boldsymbol{x}^{\ast}) \leq g(\boldsymbol{x})\)</span> for all <span class="math inline">\(\boldsymbol{x}\)</span> in a small neighbourhood of <span class="math inline">\(\boldsymbol{x}^{\ast}\)</span>. A necessary condition for a local minimum (for a sufficiently smooth function) is that <span class="math inline">\(\nabla g(\boldsymbol{x}^{\ast})=\boldsymbol{0}\)</span> where <span class="math inline">\(\nabla\)</span> is the gradient operator given by <span class="math display">\[\nabla \equiv \begin{pmatrix} \frac{\partial }{\partial x_1} \\ \frac{\partial }{\partial x_2} \\ \vdots \\ \frac{\partial }{\partial x_N} \end{pmatrix}.\]</span> Many algorithms are available for finding local minima but the global minimum is much more difficult since <span class="math inline">\(g(\boldsymbol{x}^{\ast})\)</span> must be smaller than <em>all</em> <span class="math inline">\(\boldsymbol{x}\)</span> in the entire domain of <span class="math inline">\(g\)</span>. Finding the global minimum of a general function <span class="math inline">\(g\)</span> is not a simple task. Only recently have effective algorithms developed, these include <em>Simulated Annealing</em> and <em>Genetic Algorithms</em>. These algorithms are used mostly in bioinformatic industries for tasks such as protein design, and by the power generating industry to schedule the on-off times of its power stations.</li>
</ul>
</section>
<section id="method-of-steepest-descent" class="level2" data-number="J.7">
<h2 data-number="J.7" class="anchored" data-anchor-id="method-of-steepest-descent"><span class="header-section-number">J.7</span> Method of Steepest Descent</h2>
<p>The simplest way to find a local minimum is the <em>Method of Steepest Decent</em>. This method starts from the realisation that for a function <span class="math inline">\(g: \mathbb{R}^{N} \to \mathbb{R}\)</span> and a point <span class="math inline">\(\boldsymbol{x}_0 \in \mathbb{R}^N\)</span>, the function <span class="math inline">\(g\)</span> decreases most rapidly in the direction <span class="math inline">\(-\nabla g(\boldsymbol{x}_0)\)</span>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Indeed, consider the unit direction <span class="math inline">\(\hat{\boldsymbol{d}}\)</span> where <span class="math display">\[\left.\frac{\mathrm{d} }{\mathrm{d} t} \left\{  g(\boldsymbol{x}_0 + t \hat{\boldsymbol{d}} )  \right\} \right|_{t = 0} \quad \text{is minimised}.\]</span> By using the chain rule, this implies that <span class="math display">\[\left. \nabla g(\boldsymbol{x}_0 + t \hat{\boldsymbol{d}} ) \cdot \hat{\boldsymbol{d}} \right| _{t = 0} \quad \text{is minimised}.\]</span> Therefore, this implies that <span class="math inline">\(\nabla g(\boldsymbol{x}_0) \cdot \hat{\boldsymbol{d}}\)</span> should be “as negative as possible”. By the Cauchy-Schwarz inequality<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, <span class="math display">\[\nabla g(\boldsymbol{x}_0) \cdot \hat{\boldsymbol{d}} \leq \| \nabla g(\boldsymbol{x}_0 ) \|_2 \|\hat{\boldsymbol{d}}\|_2 =\|\nabla g(\boldsymbol{x}_0 )\|_2 \quad \text{since $\hat{\boldsymbol{d}}$ is a unit vector.}\]</span> In order for the equality to hold, <span class="math inline">\(\hat{\boldsymbol{d}}\)</span> should be a scalar multiple of <span class="math inline">\(\nabla g(\boldsymbol{x}_0)\)</span>, i.e.&nbsp;<span class="math inline">\(\hat{\boldsymbol{d}}=\lambda \nabla g(\boldsymbol{x}_0)\)</span> for some <span class="math inline">\(\lambda \in \mathbb{R}\)</span>. In this case, since <span class="math inline">\(\hat{\boldsymbol{d}}\)</span> is a unit vector and it is intended to minimise, then <span class="math display">\[\hat{\boldsymbol{d}}=-\frac{\nabla g(\boldsymbol{x}_0)}{\| \nabla g(\boldsymbol{x}_0) \|}\]</span> meaning that the direction of steepest descent is <span class="math inline">\(-\nabla g(\boldsymbol{x}_0)\)</span>. Note that in order to maximise the function <span class="math inline">\(g\)</span>, the direction of steepest <em>ascen</em>} is <span class="math display">\[\hat{\boldsymbol{d}}=\frac{\nabla g(\boldsymbol{x}_0)}{\| \nabla g(\boldsymbol{x}_0) \|}.\]</span></p>
</div>
</div>
<p>The method of steepest descent can be described as follows: For a starting point <span class="math inline">\(\boldsymbol{x}_0 \in \mathbb{R}^N\)</span> and <span class="math inline">\(k \geq 0\)</span>:</p>
<ul>
<li>Let <span class="math inline">\(\boldsymbol{x}_{k+1}=\boldsymbol{x}_k-t\nabla g(\boldsymbol{x}_k)\)</span>;</li>
<li>Find the expression for <span class="math inline">\(g(\boldsymbol{x}_{k+1})\)</span> in terms of <span class="math inline">\(t\)</span>;</li>
<li>Find the value of <span class="math inline">\(t\)</span> which minimises <span class="math inline">\(g(\boldsymbol{x}_{k+1})\)</span>;</li>
<li>Update <span class="math inline">\(k \to k+1\)</span> and repeat Steps 1-3 until <span class="math inline">\(g(\boldsymbol{x}_{k})\)</span> cannot be reduced further. One possible stopping criterion would be <span class="math display">\[|g(\boldsymbol{x}_{k+1})-g(\boldsymbol{x}_k)|&lt;\tau\]</span> for some tolerance <span class="math inline">\(\tau&gt;0\)</span>.</li>
</ul>
<p>Note that Step 3 is a one-dimensional minimisation problem. It involves minimising a function of a <em>single</em> variable <span class="math inline">\(t\)</span>. This is conceptually an easy thing to do; just go downhill in one direction until it is not possible to go any further. There are many methods of doing this including the <em>Bisection</em> and the (faster) <em>Golden Search Method</em>.</p>
<p>The method of steepest descent is conceptually easy to understand and implement, however, the algorithm needs to calculate <span class="math inline">\(\nabla g\)</span> at every step. The method can also be slow since the sequence of search directions are are always orthogonal to one another, meaning that the algorithm can often times make repeated searches in every direction since it will follow a perpendicular zigzag pattern.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Caution
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider the function <span class="math inline">\(g:\mathbb{R}^2 \to \mathbb{R}\)</span> where <span class="math display">\[g(x,y) = (x-y)^2 +(x^2 +y^2 -1)^2.\]</span> The method of steepest descent is shown below with four different calculations from different starting points.</p>
<p><img src="figures/Contour.jpg" class="img-fluid"> <img src="figures/sd.jpg" class="img-fluid"></p>
</div>
</div>
</section>
<section id="variants-of-the-newton-raphson-method" class="level2" data-number="J.8">
<h2 data-number="J.8" class="anchored" data-anchor-id="variants-of-the-newton-raphson-method"><span class="header-section-number">J.8</span> Variants of the Newton-Raphson Method</h2>
<p>A special case of the NR for a system of equations would be to take the vector-valued function <span class="math inline">\(\boldsymbol{f}\)</span> to be equal to gradient of a function <span class="math inline">\(g\)</span>, i.e.&nbsp;<span class="math inline">\(\boldsymbol{f}=\nabla g\)</span>. This means that the NR can be used in order to implement the steepest descent method. In this case, if <span class="math inline">\(\boldsymbol{f}=\nabla g\)</span>, then the Jacobian will in fact become the <em>Hessian</em> matrix. For instance, if <span class="math inline">\(\boldsymbol{f}(x,y,z)=\nabla g(x,y,z)\)</span>, then <span class="math display">\[\boldsymbol{f}(\boldsymbol{x})=\begin{pmatrix} \frac{\partial g}{\partial x} \\ \frac{\partial g}{\partial y} \\ \frac{\partial g}{\partial z} \end{pmatrix}(\boldsymbol{x}) \quad \text{and} \quad H=J(\boldsymbol{x})=\begin{pmatrix}
\frac{\partial^2 g}{\partial x^2} &amp; \frac{\partial^2 g}{\partial x \partial y} &amp; \frac{\partial^2 g}{\partial x \partial z} \\
\frac{\partial^2 g}{\partial y \partial x} &amp; \frac{\partial^2 g}{\partial y^2} &amp; \frac{\partial^2 g}{\partial y \partial z} \\
\frac{\partial^2 g}{\partial z \partial x} &amp; \frac{\partial^2 g}{\partial z \partial y} &amp; \frac{\partial^2 g}{\partial z^2} \end{pmatrix}(\boldsymbol{x}).
\]</span> In general, the elements of the Hessian matrix/Jacobian (which is symmetric) are given by <span class="math display">\[H=J(\boldsymbol{x})_{ij}=\frac{\partial^2 g_i }{\partial x_i \; \partial x_j} \quad \text{for all} \quad i,j = 1,2\dots, N.\]</span> Therefore, NR for <span class="math inline">\(\boldsymbol{f}=\nabla g\)</span> is <span class="math display">\[\boldsymbol{x}_{k+1}=\boldsymbol{x}_k+\boldsymbol{d}_k \quad \text{with $\boldsymbol{d}_k$ satisfying} \quad H_k \boldsymbol{d}_k=-\nabla g(\boldsymbol{x}_k)\]</span> where <span class="math inline">\(H_k=J(\boldsymbol{x}_k)\)</span> is the Hessian matrix. Many methods attempt to approximate this by using the iteration <span class="math display">\[\boldsymbol{x}_{k+1}=\boldsymbol{x}_k+t_k H_k^{-1}\boldsymbol{d}_k\]</span> where <span class="math inline">\(t_n\)</span> is a stepsize, <span class="math inline">\(\boldsymbol{d}_n\)</span> is the approximate search direction (usually <span class="math inline">\(\boldsymbol{d}_n \approx -\nabla g(\boldsymbol{x}_n)\)</span>) and <span class="math inline">\(H_k^{-1}\)</span> is the inverse of the Hessian matrix, or at least an approximation to the Hessian. Note that the steepest descent method is one example of this general form where <span class="math inline">\(t_k\)</span> is the result of a line search, <span class="math inline">\(\boldsymbol{d}_k = -\nabla g(\boldsymbol{x}_k)\)</span> and <span class="math inline">\(H_k\)</span> is the identity.</p>
</section>
<section id="applications-of-minimisation-methods" class="level2" data-number="J.9">
<h2 data-number="J.9" class="anchored" data-anchor-id="applications-of-minimisation-methods"><span class="header-section-number">J.9</span> Applications of Minimisation Methods</h2>
<ul>
<li><p><strong>The minimisation of large systems</strong>: An interesting example of this arises in elliptic partial differential equations (for example problems in elasticity or electrostatics), where the solution minimises a function related to the energy of the system. Complicated engineering structures are designed by finding the local minima of a possible configuration as this represents a stable operating structure.</p></li>
<li><p><strong>Solving symmetric, positive definite linear systems</strong>: For the linear system given by <span class="math inline">\(A\boldsymbol{x}=\boldsymbol{b}\)</span> where <span class="math inline">\(A\)</span> is a symmetric positive definite matrix, an approach to do this is by <em>minimising</em> the function <span class="math display">\[g(\boldsymbol{x}) = \frac{1}{2} {\boldsymbol{x}}^{\mathrm{T}} A\boldsymbol{x}-{\boldsymbol{b}}^{\mathrm{T}} \boldsymbol{x}.\]</span> This is the basis of the celebrated <em>Conjugate Gradient</em> method. There are also variants for non-symmetric matrices.</p></li>
<li><p><strong>Solving non-linear systems</strong>: For a non-linear system of the form <span class="math display">\[\boldsymbol{f}(\boldsymbol{x})=\boldsymbol{0} \quad \implies \quad\begin{pmatrix} f_1 \\ f_2 \\ \vdots \\ f_N \end{pmatrix}(\boldsymbol{x})=\begin{pmatrix} 0 \\ 0 \\ \vdots \\ 0 \end{pmatrix},\]</span> a solution <span class="math inline">\(\boldsymbol{x}^{\ast}\)</span> would need to be found by <em>minimising</em> the function <span class="math display">\[ g(\boldsymbol{x}) =  \| \boldsymbol{f}(\boldsymbol{x}) \|_2^2 = \sum_{n=1}^{N} | f_n(\boldsymbol{x})|^2\]</span> or more generally <span class="math display">\[g(\boldsymbol{x}) = \sum_{n=1}^{N} \alpha_n | f_n(\boldsymbol{x}) |^2\]</span> where <span class="math inline">\(\alpha_n &gt; 0\)</span> are suitably chosen weights. However, in order to solving the system <span class="math inline">\(\boldsymbol{f}(\boldsymbol{x})=\boldsymbol{0}\)</span> requires finding the global minimum of <span class="math inline">\(g\)</span> and unconstrained minimisation algorithms will only find a local minimum. If the initial guess for the solution is good enough, then the “local” minimum of <span class="math inline">\(g\)</span> near the initial guess will also be a “global” minimum.</p></li>
</ul>


</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>For a function <span class="math inline">\(f:\mathbb{R}\to \mathbb{R}\)</span>, Taylor’s theorem states that for two points <span class="math inline">\(x,y \in \mathbb{R}\)</span> which are close to one another: <span class="math display">\[f(y) \sim f(x)+f'(x)(y-x)+\frac{1}{2!}f''(\xi)(y-x)^2 \quad \text{for some $\xi$ between $x$ and $y$.} \quad\]</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Recall that for vectors <span class="math inline">\(\boldsymbol{u}\)</span> and <span class="math inline">\(\boldsymbol{v}\)</span>, the Cauchy-Schwarz inequality states that <span class="math display">\[|\langle \boldsymbol{u},\boldsymbol{v} \rangle| \leq \| \boldsymbol{u} \|_2 \| \boldsymbol{v} \|_2\]</span> where in this case, the inner product is simply the dot product. Note that equality hold only when <span class="math inline">\(\boldsymbol{u}\)</span> and <span class="math inline">\(\boldsymbol{v}\)</span> are linearly <em>dependent</em>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation column-body">
  <div class="nav-page nav-page-previous">
      <a href="./Z_App_Eigen.html" class="pagination-link" aria-label="Eigenvalue Problems">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">I</span>&nbsp; <span class="chapter-title">Eigenvalue Problems</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




</body></html>