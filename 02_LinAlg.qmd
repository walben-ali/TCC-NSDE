{{< include _macros.qmd >}}
:::

# Solving Linear Systems of Equations

Before embarking on the main purpose of the course, which is solving differential equations, first solving linear systems will be necessary.  The linear systems will take the form
$$A\B{x}=\B{b} \qtq{where} A \in \CC^{N \times N}, \B{x} \in \CC^N \qtq{and} \B{b} \in \CC^N.$$
This is a situation when the LHS forms a system of equations with a vector of unknowns $\B{x}$ and the RHS is known.

:::{.callout-caution icon=false}
## Simple Example of a Linear System

Let $a, b$ and $c$ be integers such that:

- their sum is equal to 20
- $a$ is twice as large as $b$
- $b$ is bigger than $c$ by 10.

These three relationships can be written in equation form as:
$$a+b+c=20$$
$$a=2b$$
$$b-c=10$$

This can written in matrix form as:
$$\underbrace{\Mat{1 & 1 & 1 \\ 1 & -2 & 0 \\ 0 & 1 & -1}}_{A} \underbrace{\Mat{a \\ b \\ c}}_{\B{x}} = \underbrace{\Mat{20 \\ 0 \\ 10}}_{\B{b}}.$$
:::

There are two main ways in which this can be done, depending on the form of the matrix:

- Direct Methods:
     - Direct substitution for diagonal systems;
     - Forward substitution for lower triangular systems;
     - Backward substitution for upper triangular systems;
     - TDMA for tridiagonal systems;
     - Cramer's Rule and Gaussian Elimination for more general matrix systems.
- Iterative Methods
     - Jacobi;
     - Gauss-Seidel.
- In-built Methods:
     - Backsklash operator.

## Computational Stability of Linear Systems

Before tackling any linear algebra techniques, it is important to understand ***Computational Stability***.

Consider the linear system
$$A\B{x}=\B{b} \qtq{where} A \in \CC^{N \times N}, \B{x} \in \CC^N \qtq{and} \B{b} \in \CC^N.$$
In real-life applications, the matrix $A$ is usually fully known and often invertible while the vector $\B{b}$ may not be known exactly and its measurement may often include rounding errors.  Suppose that the vector $\B{b}$ has a small error $\delta \B{b}$, then the solution $\B{x}$ will also have a small error $\delta \B{x}$, meaning that the system will in fact be
$$A (\B{x} + \delta \B{x}) = \B{b} + \delta \B{b}.$${#eq-err1}
Subtracting $A\B{x}=\B{b}$ form @eq-err1 gives $A \delta \B{x} = \delta \B{b}$, therefore $\delta \B{x}=A^{-1} \delta \B{b}$.

For $p \in \NN$, consider the ratio between the $p$-norm of the error $\Norm{\delta \B{x}}{p}$ and the $p$-norm of the exact solution $\Norm{\B{x}}{p}$:
\begin{align*}
\frac{\Norm{\delta \B{x}}{p}}{\Norm{\B{x}}{p}} & = \frac{ \Norm{A^{-1} \delta \B{b}}{p}}{\Norm{\B{x}}{p}} && \quad \text{since} \quad \delta \B{x}=A^{-1} \delta \B{b}\\
& \leq \frac{ \Norm{A^{-1}}{p} \Norm{\delta \B{b}}{p}}{\Norm{\B{x}}{p}} && \quad \text{by the \emph{Submultiplicative Property}} \\
& = \frac{ \Norm{A^{-1}}{p} \Norm{\delta \B{b}}{p}}{\Norm{\B{x}}{p}} \times \frac{\Norm{A}{p}}{\Norm{A}{p}} && \quad \text{multiplying by} \quad 1=\frac{\Norm{A}{p}}{\Norm{A}{p}} \\
& =\Norm{A}{p} \Norm{A^{-1}}{p} \frac{\Norm{\delta \B{b}}{p}}{\Norm{A}{p} \Norm{\B{x}}{p}} && \quad \text{rearranging} \\
& \leq \Norm{A}{p} \Norm{A^{-1}}{p} \frac{\Norm{\delta \B{b}}{p}}{\Norm{\B{b}}{p}} && \quad \text{since} \; \; \B{b}=A\B{x} \; \text{then} \; \; \Norm{\B{b}}{p} \leq \Norm{A}{p} \Norm{\B{x}}{p} \\
&&& \quad \text{by the Submultiplicative Property,} \\
&&& \quad \text{meaning that}\; \; \frac{1}{\Norm{\B{b}}{p}} \geq \frac{1}{\Norm{A}{p} \Norm{\B{x}}{p}}
\end{align*}

:::{#nte-SubMult .callout-note}
## Submultiplicative Property of Matrix Norms

For matrices $A$ and $B$ and a vector $\B{x}$,
$$\| A\B{x} \| \leq \| A \| \| \B{x} \|,$$
$$\| AB \| \leq \|A\| \|B\|.$$
In both cases, the equality holds when either $A$ or $B$ are orthogonal.
:::

Let $\kappa_p(A)=\Norm{A^{-1}}{p} \Norm{A}{p}$, then
$$\frac{\Norm{\delta \B{x}}{p}}{\Norm{\B{x}}{p} } \leq \kappa_p(A) \frac{\Norm{\delta \B{b}}{p}}{\Norm{\B{b}}{p}}$$

The quantity $\kappa_p(A)$ is called the ***Condition Number***[^Cond] and it can be regarded as a measure of how sensitive a matrix is to perturbations, in other words, it gives an indication as to the stability of the matrix system.  A problem is ***Well-Conditioned*** if the condition number is small, and is ***Ill-Conditioned*** if the condition number is large (the terms "*small*" and "*large*" are somewhat subjective here and will depend on the context).  Bear in mind that in practice, calculating the condition number may be computationally expensive since it requires inverting the matrix $A$.

[^Cond]:  Note that $A^{-1}$ exists only if $A$ is non-singular, meaning that the condition number number only exists if $A$ is non-singular.

The condition number derived above follows the assumption that the error only occurs in $\B{b}$ which then results in an error in $\B{x}$.  If an error $\delta A$ is also committed in $A$, then for sufficiently small $\delta  A$, the error bound for the ratio is
$$\frac{\Norm{\delta \B{x}}{p}}{\Norm{\B{x}}{p}} \leq \frac{\kappa_p(A)}{ 1 - \kappa_p(A) \frac{\Norm{\delta A}{p}}{\Norm{A}{p}}} \left( \frac{\Norm{\delta \B{b}}{p}}{\Norm{\B{b}}{p}} + \frac{\Norm{\delta A}{p}}{\Norm{A}{p}} \right).$$

An example for which $A$ is large is a discretisation matrix of a PDE, in this case, the condition number of $A$ can be very large and increases rapidly as the number of mesh points increases.  For example, for a PDE with $N$ mesh points in 2-dimensions, the condition number $\kappa_2(A)$ is of order $\OO{N}$ and it is not uncommon to have $N$ between $10^6$ and $10^8$.  In this case, errors in $\B{b}$ may be amplified enormously in the solution process.  Thus, if $\kappa_p(A)$ is large, there may be difficulties in solving the system reliably, a problem which plagues calculations with partial differential equations. 

Moreover, if $A$ is large, then the system $A\B{x}= \B{b}$ may be solved using an *iterative method* which generate a sequence of approximations $\B{x}_n$ to $\B{x}$ while ensuring that each iteration is easy to perform and that $\B{x}_n$ rapidly tends to $\B{x}$, within a certain tolerance, as $n$ tends to infinity.  If $\kappa_p(A)$ is large, then the number of iterations to reach this tolerance increases rapidly as the size of $A$ increases, often being proportional to $\kappa_p(A)$ or even to $\kappa_p(A)^2$.  Thus not only do errors in $\B{x}$ accumulate for large $\kappa_p(A)$, but the number of computation required to find $\B{x}$ increases as well.

In MATLAB, the condition number can be calculated using the `cond(A,p)` command where `A` is the square matrix in question and `p` is the chosen norm which can only be equal to `1`, `2`, `inf` or `'Fro'` (when using the Frobenius norm).  Also note that `cond(A)` without the second argument `p` produces the condition number with the 2-norm by default.

#### Properties of the Condition Number {.unnumbered}

Let $A$ and $B$ be invertible matrices, $p \in \mathbb{N}$ and $\lambda \in \mathbb{R}$.  The condition number $\kappa_p$ has the following properties:

- $\kappa_p(A) \geq 1$;
- $\kappa_p(A)=1$ if and only if $A$ is an orthogonal matrix, i.e. $A^{-1}=A^{\mathrm{T}}$;
- $\kappa_p(\Tr{A})=\kappa_p(A^{-1})=\kappa_p(A)$;
- $\kappa_p(\lambda A)=\kappa_p(A)$;
- $\kappa_p(AB) \leq \kappa_p(A)\kappa_p(B)$.

## Direct Methods {#sec-Dir}

Direct methods can be used to solve matrix systems in a finite number of steps, although these steps could possibly be computationally expensive.

### Direct Substitution

Direct substitution is the simplest direct method and requires the matrix $A$ to be a diagonal with none of the diagonal terms being 0 (otherwise the matrix will not be invertible).

Consider the matrix system $A \B{x}=\B{b}$ where
$$A=\Mat{a_1 \\ & a_2 \\ && \ddots \\ &&& a_{N-1} \\ &&&& a_{N}}, \quad \B{x}=\Mat{x_1 \\ x_2 \\ \vdots \\ x_{N-1} \\ x_N} \qtq{and} \B{b}=\Mat{b_1 \\ b_2 \\ \vdots \\ b_{N-1} \\ b_N}$$
and $a_1, a_2, \dots, a_N \neq 0$.  Direct substitution involves simple multiplication and division:
$$A\B{x}=\B{b} \qiq \Mat{a_1 \\ & a_2 \\ && \ddots \\ &&& a_{N-1} \\ &&&& a_N}\Mat{x_1 \\ x_2 \\ \vdots \\ x_{N-1} \\ x_{N}}=\Mat{b_1 \\ b_2 \\ \vdots \\ b_{N-1} \\ b_N}$$
$$\iq \mat{a_1 x_1 = b_1 \\ a_2 x_2 = b_2 \\ \vdots \\ a_{N-1}x_{N-1}=b_{N-1} \\ a_N x_N=b_N} \qiq \mat{x_1=\frac{b_1}{a_1} \\ x_2=\frac{b_2}{a_2} \\ \vdots \\ x_{N-1}=\frac{b_{N-1}}{a_{N-1}} \\ x_N=\frac{b_N}{a_N}.}$$

The solution can be written explicitly as $x_n=\frac{b_n}{a_n}$ for all $n=1,2,\dots,N$.  Every step can done independently, meaning that direct substitution lends itself well to parallel computing.  In total, direct substitution requires exactly $N$ computations (all being division).

:::{.callout-caution icon=false}
## Example of Direct Substituion

Consider the system $A\B{x}=\B{b}$ where
$$A=\Mat{1 & 0 & 0 \\ 0 & 2 & 0 \\ 0 & 0 & -1}, \quad \B{x}=\Mat{x_1 \\ x_2 \\ x_3} \qtq{and} \B{b}=\Mat{4 \\ 2 \\ 4}.$$
Solving the system using direct substitution:
$$A\B{x}=\B{b} \qiq \Mat{1 & 0 & 0 \\ 0 & 2 & 0 \\ 0 & 0 & -1}\Mat{x_1 \\ x_2 \\ x_3}=\Mat{4 \\ 2 \\ 4}$$
$$\iq \Mat{x_1 \\ 2x_2 \\ -x_3}=\Mat{4 \\ 2 \\ 4} \qiq \mat{x_1=4 \\ x_2=1 \\ x_3=-4.}$$
:::

### Forward/Backward Substitution

Forward/backward substitution require that the matrix $A$ be lower/upper triangular.

Consider the matrix system $A \B{x}=\B{b}$ where
$$A=\Mat{a_{11} & a_{12} & \dots & a_{1,N-1} & a_{1N} \\ & a_{22} & \dots & a_{2,N-1} & a_{2N} \\ && \ddots & \vdots \\ &&& a_{N-1,N-1} & a_{N-1,N} \\ &&&& a_{NN}},$$
$$\B{x}=\Mat{x_1 \\ x_2 \\ \vdots \\ x_{N-1} \\ x_N} \qtq{and} \B{b}=\Mat{b_1 \\ b_2 \\ \vdots \\ b_{N-1} \\ b_N}$$
and $a_{11}, a_{22}, \dots, a_{NN} \neq 0$ (so that the determinant is non-zero).  The matrix $A$ is upper triangular in this case and will require backwards substitution:
$$A\B{x}=\B{b} \qiq \Mat{a_{11} & a_{12} & \dots & a_{1,N-1} & a_{1N} \\ & a_{22} & \dots & a_{2,N-1} & a_{2N} \\ && \ddots & \vdots \\ &&& a_{N-1,N-1} & a_{N-1,N} \\ &&&& a_{NN}}\Mat{x_1 \\ x_2 \\ \vdots \\ x_{N-1} \\ x_N}=\Mat{b_1 \\ b_2 \\ \vdots \\ b_{N-1} \\ b_N.}$$

$$\iq \begin{matrix}
a_{11}x_1 &+& a_{12}x_2 &+& \dots  &+& a_{1,N-1} x_{N-1}   &+& a_{1N}x_N    &= b_1     \\
          & & a_{22}x_2 &+& \dots  &+& a_{2,N-1} x_{N-1}   &+& a_{2N}x_N    &= b_2     \\
          & &           & & \vdots & &                     & &              &          \\
          & &           & &        & & a_{N-1,N-1} x_{N-1} &+& a_{N-1,N}x_N &= b_{N-1} \\
          & &           & &        & &                     & & a_{NN}x_N    &= b_N
\end{matrix}$$

Backward substitution involves using the solutions from the later equations to solve the earlier ones, this gives:
$$x_N=\frac{b_N}{a_{NN}}$$
$$x_{N-1}=\frac{b_{N-1}-a_{N-1,N}x_N}{a_{N-1,N-1}}$$
$$\vdots$$
$$x_2=\frac{b_2-a_{2N}x_N-a_{2,N-1}x_{N-1}-\dots-a_{23}x_3}{a_{22}}$$
$$x_1=\frac{b_1-a_{1N}x_N-a_{1,N-1}x_{N-1}-\dots-a_{12}x_2}{a_{11}}.$$

This can be written more explicitly as:
$$x_n=\begin{cases}
\frac{b_N}{a_{NN}} & \qtq{for} n=N \\
\frac{1}{a_{nn}}\nbr{b_n - \sum_{i=n+1}^{N}{a_{ni}x_i}} & \qtq{for} n=N-1, \dots, 2, 1.
\end{cases}$$
A similar version can be obtained for the forward substitution for lower triangular matrices as follows:
$$x_n=\begin{cases}
\frac{b_1}{a_{11}} & \qtq{for} n=1 \\
\frac{1}{a_{nn}}\nbr{b_n - \sum_{i=1}^{n-1}{a_{ni}x_i}} & \qtq{for} n= 2, 3, \dots, N-1.
\end{cases}$$

For any $n=1,2,\dots,N-1$, calculating it requires 1 division, $N-n$ multiplications and $N-n$ subtractions.  Therefore cumulatively, $x_1, x_2, \dots, x_{N-1}$ require $N$ divisions, $\frac{1}{2}\nbr{N^2-N}$ multiplications and $\frac{1}{2}\nbr{N^2-N}$ additions with one more division required for $x_N$, meaning that in total, backward (and forward) substitution requires $N^2+1$ computations.

:::{.callout-caution icon=false}
## Example of Backward Substitution

Consider the system $A\B{x}=\B{b}$ where
$$A=\Mat{1 & 2 & 1 \\ 0 & -1 & 4 \\ 0 & 0 & -1}, \quad \B{x}=\Mat{x_1 \\ x_2 \\ x_3} \qtq{and} \B{b}=\Mat{1 \\ 0 \\ 1}.$$
This problem can be solved by suing backward substitution:
$$A\B{x}=\B{b} \qiq \Mat{1 & 2 & 1 \\ 0 & -1 & 4 \\ 0 & 0 & -1}\Mat{x_1 \\ x_2 \\ x_3}=\Mat{1 \\ 0 \\ 1} \qiq \mat{x_1+2x_2+x_3=1 \\ -x_2+4x_3=0 \\ -x_3=1}$$
$$-x_2+4x_3=0 \mathimplies{x_3=-1} -x_2-4=0 \qiq x_2=-4$$
$$x_1+2x_2+x_3=1 \mathimplies{x_2=-4, \; x_3=-1} x_1-8-1=1 \qiq x_1=10.$$
:::

### TDMA Algorithm {#sec-TDMA}

The ***TriDiagonal Matrix Algorithm***, abbreviated as ***TDMA*** (also called the ***Thomas Algorithm***) was developed by Llewellyn Thomas which solves tridiagonal matrix systems.

Consider the matrix system $A \B{x}=\B{b}$ where
$$A=\Mat{m_1 & r_1 \\ l_2 & m_2 & r_2 \\ & \ddots & \ddots & \ddots \\ && l_{N-1} & m_{N-1} & r_{N-1} \\ &&& l_N & m_N},$$
$$\B{x}=\Mat{x_1 \\ x_2 \\ \vdots \\ x_{N-1} \\ x_N} \qtq{and} \B{b}=\Mat{b_1 \\ b_2 \\ \vdots \\ b_{N-1} \\ b_N}.$$
The $m$ terms denote the diagonal elements, $l$ denote subdiagonal elements (left of the diagonal terms) and $r$ denote the superdiagonal elements (right of the diagonal terms).  The TDMA algorithm works in two steps: first, TDMA performs a forward sweep to eliminate all the subdiagonal terms and rescale the matrix to have 1 as the diagonal (the same can also be done to eliminate the superdiagonal instead).  This give the matrix system
$$\Mat{1 & R_1 \\ & 1 & R_2 \\ & & \ddots & \ddots \\ && & 1 & R_{N-1} \\ &&& & 1}\Mat{x_1 \\ x_2 \\ \vdots \\ x_{N-1} \\ x_N}=\Mat{B_1 \\ B_2 \\ \vdots \\ B_{N-1} \\ B_N}$$
where
$$R_n=
\begin{cases}
\frac{r_1}{m_1} & n=1 \\ \frac{r_n}{m_n-l_n R_{n-1}} & n=2,3,\dots,N-1
\end{cases}$$
$$B_n=
\begin{cases}
\frac{b_1}{m_1} & n=1 \\ \frac{b_n-l_n B_{n-1}}{m_n - l_n R_{n-1}} & n=2,3,\dots,N.
\end{cases}$$

This can now be solved with backward substitution:
$$x_n=
\begin{cases}
B_N & n=N \\ B_n-R_n x_{n+1} & n=N-1, N-2, \dots, 2, 1.
\end{cases}$$

The computational complexity can be calculated as follows:

| Term      | $\times$ | $+$      | $\div$   |
|:---------:|:--------:|:--------:|:--------:|
| $R_1$     | 0        | 0        | 1        |
| $R_2$     | 1        | 1        | 1        |
| $\vdots$  | $\vdots$ | $\vdots$ | $\vdots$ |
| $R_{N-1}$ | 1        | 1        | 1        |
| $B_1$     | 0        | 0        | 1        |
| $B_2$     | 2        | 2        | 1        |
| $\vdots$  | $\vdots$ | $\vdots$ | $\vdots$ |
| $B_{N-1}$ | 2        | 2        | 1        |
| $B_N$     | 2        | 2        | 1        |
| $x_1$     | 1        | 1        | 0        |
| $x_2$     | 1        | 1        | 0        |
| $\vdots$  | $\vdots$ | $\vdots$ | $\vdots$ |
| $x_{N-1}$ | 1        | 1        | 0        |

This gives a total of $3N-5$ computations for $R$, $5N-4$ computations for $B$ and $2N-2$ computations for $x$ giving a total of $10N-11$ computations.

There are similar ways of performing eliminations that be done for pentadiagonal systems as well as tridiagonal systems with a full first row.

### Cramer's Rule

***Cramer's Rule*** is a method that can be used to solve *any* system $A\B{x}=\B{b}$ (of course provided that $A$ is non-singular).

Cramer's rule states that the elements of the vector $\B{x}$ are given by
$$x_n = \frac{\text{det}(A_n)}{\text{det}(A)} \qtq{for all} n = 1,2,\dots,N$$
where $A_n$ is the matrix obtained from $A$ by replacing the $\nth{n}$ column by $\B{b}$.  This method seems very simple to execute thanks to its very simple formula, but in practice, it can be very computationally expensive.

:::{.callout-caution icon=false}
## Example of Cramer's Rule

Consider the system $A\B{x}=\B{b}$ where
$$A=\Mat{0 & 4 & 7 \\ 1 & 0 & 1 \\ 0 & 1 & 0} \qtq{and} \B{b}=\Mat{14 \\ 1 \\ 7}.$$
The determinant of $A$ is equal to 7.  Using Cramer's rule, the solution $\B{x}=\Tr{\nbr{x_1, \; x_2, \; x_3}}$ can be calculated as:
$$x_1=\frac{\det(A_1)}{\det(A)}=\frac{\det \Mat{14 & 4 & 7 \\ 1 & 0 & 1 \\ 7 & 1 & 0}}{7}=\frac{21}{7}=3.$$
$$x_2=\frac{\det(A_1)}{\det(A)}=\frac{\det \Mat{0 & 14 & 7 \\ 1 & 1 & 1 \\ 0 & 7 & 0}}{7}=\frac{49}{7}=7.$$
$$x_3=\frac{\det(A_1)}{\det(A)}=\frac{\det \Mat{0 & 4 & 14 \\ 1 & 0 & 1 \\ 0 & 1 & 7}}{7}=\frac{-14}{7}=-2.$$
:::

Generally, for a matrix of size $N \times N$, the determinant will require $\OO{N!}$ computations (other matrix forms or methods may require fewer, of $\OO{N^3}$ at least).  Cramer's rule requires calculating the determinants of $N+1$ matrices each is size $N \times N$ and performing $N$ divisions, therefore the computational complexity of Cramer's rule is $\OO{N+(N+1) \times N!}=\OO{N+(N+1)!}$.  This means that if a machine runs at 1 Gigaflops per second ($10^9$ flops), then a matrix system of size $20 \times 20$ will require 1620 years to compute.

### Gaussian Elimination & LU Factorisation

Consider the linear system
$$A \B{x} = \B{b} \qtq{where} A \in \RR^{N \times N}, \quad \B{x} \in \RR^N, \quad \B{b} \in \RR^N.$$
In real-life situations, the matrix $A$ does not always have a form that lends itself to being easily solvable (like a diagonal, triangular, sparse, etc.).  However, there are ways in which a matrix can be broken down into several matrices, each of which can be dealt with separately and reducing computational time.

One way of doing this is by ***Gaussian Elimination*** which is a series of steps that reduces a matrix $A$ into an upper triangular matrix.  The steps of the Gaussian elimination are presented in details in @sec-GE.

In order to convert the linear system $A\B{x}=\B{b}$ into the upper triangular matrix system $U\B{x}=\B{g}$ by Gaussian elimination, a series of transformations have to be done, each represented by a matrix $M^{(n)}$ giving the form
$$U=M A \qtq{where} M=M^{(N-1)} M^{(N-2)} \dots M^{(1)}.$$
For every $n=1,2,\dots,N-1$, the matrix $M^{(n)}$ is lower triangular (because the process is intended to eliminate the lower triangular elements) which means that the product of all these matrices $M$ must also be lower triangular.  Note that since $M^{(n)}$ and $M$ are both non-singular and lower triangular, then their inverses must also be lower triangular.  This means that the matrix $L=M^{-1}$ will be lower triangular and invertible.  Additionally, since Gaussian elimination tends to keep the diagonal terms unchanged, then the diagonal terms of $M$, and consequently $L$, will all be 1.

This means that the matrix $A$ can be written as $A=LU$ where $L=M^{-1}$ is a lower triangular matrix and $U$ is an upper triangular matrix.  This is called the ***LU Decomposition*** of $A$.

In the cases when there might be pivoting issues (which is when the pivot points might be equal to 0 during the Gaussian Elimination), the LU decomposition will more precisely be the ***PLU Decomposition*** (or the ***LU Decomposition with Partial Pivoting***) where the method will produce an additional permutation matrix $P$ where $PA=LU$.  This matrix $P$ will swap rows when needed in order to have non-zero pivot points and is in fact orthogonal (i.e. $P^{-1}=\Tr{P}$).

The LU decomposition can be used to solve the linear system $A\B{x}=\B{b}$ by splitting the matrix $A$ into two matrices with more manageable forms.  Indeed, since $A=LU$, then the system becomes $LU\B{x}=\B{b}$, this can be solved as follows:

- Solve the lower triangular system $L\B{y}=\B{b}$ for $\B{y}$ using forward substitution;
- Solve the upper triangular $U\B{x}=\B{y}$ for $\B{x}$ using backwards substitution.

This is a much better way of solving the system since both equations involve a triangular matrix and this requires $\OO{N^2}$ computations (forward and backward substitutions).

The advantage of using the LU decomposition is that if problems of the form $A \B{x}_i=\B{b}_i$ need to be solved with many different right hand sides $\B{b}_i$ and a fixed $A$, then only one LU decomposition is needed, and the cost for solving the individual systems is only the repeated forward and back substitutions.  Note that there are other strategies optimised for specific cases (i.e. symmetric positive definite matrices, banded matrices, tridiagonal matrices). 

In MATLAB, the LU decomposition can be done by a simple `lu` command:

```matlab
>> A=[5,0,1;1,2,1;2,1,1];
>> [L,U]=lu(A)
L =
     1.0000        0        0
     0.2000   1.0000        0
     0.4000   0.5000   1.0000
U =

     5.0000        0   1.0000
          0   2.0000   0.8000
          0        0   0.2000
>> L*U-A       % Verify if LU is equal to A
ans =
     0   0   0
     0   0   0
     0   0   0
```

Note that if the output for `L` is *not* lower triangular, that means there are some pivoting issues that had to be overcome and `L` had to change to accommodate for that to maintain the fact that $A=LU$.  In this case, the PLU decomposition would be better suited to avoid that, this is done by adding one extra output to the `lu` command, in this case, $A$ will actually be the product $A=\Tr{P}LU$.

```matlab
>>> A=[1,0,1;1,0,1;2,1,1];
>> [L,U]=lu(A)
L =
     0.5000    1.0000    1.0000
     0.5000    1.0000         0
     1.0000         0         0
U =

     2.0000    1.0000    1.0000
          0   -0.5000    0.5000
          0         0         0
>> L*U-A       % Verify if LU is equal to A even though
               % L is not lower triangular
ans =
     0   0   0
     0   0   0
     0   0   0
>> [L,U,P]=lu(A)
L =
     1.0000         0         0
     0.5000    1.0000         0
     0.5000    1.0000    1.0000
U =

     2.0000    1.0000    1.0000
          0   -0.5000    0.5000
          0         0         0
P =
     0   0   1
     0   1   0
     1   0   0
>> L*U-A       % Verify if P'LU is equal to A
ans =
     0   0   0
     0   0   0
     0   0   0
```

### Other Direct Methods

There are many other direct methods with more involved calculations like *QR decomposition* and *Singular Value Decomposition* amongst others.  All these methods will be placed in @sec-MatDeco.

## Iterative Methods

For a large matrix $A$, solving the system $A\B{x} = \B{b}$ directly can be computationally restrictive as seen in the different methods shown in @sec-Dir.  An alternative would be to use *iterative* methods which generate a sequence of approximations $\B{x}^{(k)}$ to the exact solution $\B{x}$.  The hope is that the iterative method converges to the exact solution, i.e.
$$\lim_{k \to \infty}\B{x}^{(k)}=\B{x}.$$

A possible strategy to realise this process is to consider the following recursive definition
$$\B{x}^{(k)} = B\B{x}^{(k-1)}+\B{g} \qtq{for} k\geq 1,$$
where $B$ is a suitable matrix called the ***Iteration Matrix*** (which would generally depend on $A$) and $\B{g}$ is a suitable vector (depending on $A$ and $\B{b}$).  Since the iterations $\B{x}^{(k)}$ must tend to $\B{x}$ as $k$ tends to infinity, then
$$\B{x}^{(k)} = B\B{x}^{(k-1)}+\B{g}$${#eq-Bxgk}
$$\mathimplies{k \to \infty} \B{x}=B\B{x}+\B{g}.$${#eq-Bxg}

Next, a sufficient condition needs to be derived; define $\B{e}^{(k)}$ as the error incurred from iteration $k$, i.e. $\B{e}^{(k)} := \B{x} - \B{x}^{(k)}$ and consider the linear systems
$$\B{x} = B\B{x}+\B{g} \qtq{and} \B{x}^{(k)} = B\B{x}^{(k-1)}+\B{g}.$$
Subtracting these gives
\begin{align*}
& \quad \B{x}-\B{x}^{(k)} = \nbr{B\B{x}+\B{g}}-\nbr{B\B{x}^{(k-1)}+\B{g}} \\
\implies & \quad \B{x}-\B{x}^{(k)} = B\nbr{\B{x}-\B{x}^{(k-1)}} \\
\implies & \quad \B{e}^{(k)}=B\B{e}^{(k-1)}.
\end{align*}

In order to find a bound for the error, take the 2-norm of the error equation
$$\B{e}^{(k)}=B\B{e}^{(k-1)} \mathimplies{\Norm{\cdot}{2}} \|\B{e}^{(k)}\|_2 = \|B\B{e}^{(k-1)}\|_2.$$
By the submultiplicative property of matrix norms given in @nte-SubMult, the error $\| \B{e}^{(k)} \|$ can be bounded above as
$$\Norm{\B{e}^{(k)}}{2} = \Norm{B\B{e}^{(k-1)}}{2} \leq \Norm{B}{2} \Norm{\B{e}^{(k-1)}}{2}.$$
This can be iterated backwards, so for $k \geq 1$,
$$\|\B{e}^{(k)}\|_2 \leq \| B \|_2 \|\B{e}^{(k-1)}\|_2 \leq \| B \|_2^2 \|\B{e}^{(k-2)}\|_2 \leq \dots \leq \| B \|_2^{k} \|\B{e}^{(0)}\|_2.$$
Generally, this means that the error at any iteration $k$ can be bounded above by the error at the initial iteration $\B{e}^{(0)}$.  Therefore, since $\B{e}^{(0)}$ is arbitrary, if $\| B \|_2<1$ then the set of vectors $\cbr{\B{x}^{(k)}}_{k \in \mathbb{N}}$ generated by the iterative scheme $\B{x}^{(k)}=B\B{x}^{(k-1)}+\B{g}$ will converge to the exact solution $\B{x}$ which solves $A\B{x}=\B{b}$, hence giving a sufficient condition for convergence.

### Constructing an Iterative Method

A general technique to devise an iterative method to solve $A \B{x}=\B{b}$ is based on a "splitting" of the matrix $A$.  First, write the matrix $A$ as $A = P-(P-A)$ where $P$ is a suitable non-singular matrix (somehow linked to $A$ and "easy" to invert).  Then
\begin{align*}
P\B{x} & =\sbr{A+(P-A)}\B{x} && \quad \text{since $P=A+P-A$}\\
& =(P-A)\B{x}+A\B{x} && \quad \text{expanding} \\
& =(P-A)\B{x}+\B{b} && \quad \text{since $A\B{x}=\B{b}$}
\end{align*}

Therefore, the vector $\B{x}$ can be written implicitly as
$$\B{x}=P^{-1}(P-A)\B{x}+P^{-1}\B{b}$$
which is of the form given in @eq-Bxg where $B=P^{-1}(P-A)=I-P^{-1}A$ and $\B{g}=P^{-1}\B{b}$.  It would then stand to reason that if the iterative procedure was of the form
$$\B{x}^{(k)}=P^{-1}(P-A)\B{x}^{(k-1)}+P^{-1}\B{b}$$
(as in @eq-Bxgk), then the method should converge to the exact solution (provided a suitable choice for $P$).  Of course, for the iterative procedure, the iteration needs an initial vector to start which will be
$$\B{x}^{(0)}=\Mat{x_1^{(0)} \\ x_2^{(0)} \\ \vdots \\ x_N^{(0)}}.$$

The choice of the matrix $P$ should depend on $A$ in some way.  So suppose that the matrix $A$ is broken down into three parts, $A=D+L+U$ where $D$ is the matrix of the diagonal entries of $A$, $L$ is the strictly lower triangular part or $A$ (i.e. not including the diagonal) and $U$ is the strictly upper triangular part of $A$.

:::{.callout-note}
For example
$$\underbrace{\Mat{a & b & c \\ d & e & f \\ g & h & i}}_{A}=\underbrace{\Mat{a & 0 & 0 \\ 0 & e & 0 \\ 0 & 0 & i}}_{D}+\underbrace{\Mat{ 0 & 0 & 0 \\ d & 0 & 0 \\ g & h & 0}}_{L}+\underbrace{\Mat{ 0 & b & c \\ 0 & 0 & f \\ 0 & 0 & 0}}_{U}.$$
:::

- ***Jacobi Method***: $\B{P=D}$

The matrix $P$ is chosen to be equal to the diagonal part of $A$, then the splitting procedure gives the iteration matrix $B=I-D^{-1}A$ and the iteration itself is $\B{x}^{(k)} = B\B{x}^{(k-1)}+D^{-1}\B{b}$ for $k \geq 0$, which can be written component-wise as
$$x_i^{(k)}=\frac{1}{a_{ii}}\left(b_i-\sum_{\substack{j=1 \\ j\neq i}}^{N}a_{ij}x_j^{(k-1)}\right) \qtq{for all} i=1,\dots,N.$$ {#eq-Jmethod}

If $A$ is strictly diagonally dominant by rows[^DiagDom], then the Jacobi method converges.  Note that each component $x_i^{(k)}$ of the new vector $\B{x}^{(k)}$ is computed independently of the others, meaning that the update is simultaneous which makes this method suitable for parallel programming.

[^DiagDom]:  A matrix $A \in \RR^{N \times N}$ is ***Diagonally Dominant*** if every diagonal entry is larger in absolute value than the sum of the absolute value of all the other terms in that row.  More formally
$$|a_{ii}|\geq \sum_{\substack{j=1 \\ j\neq i}}^{N}|a_{ij}| \qtq{for all} i=1,\dots,N.$$
The matrix is ***Strictly Diagonally Dominant*** if the inequality is strict.

- ***Gauss-Seidel Method***: $\B{P=D+L}$

The matrix $P$ is chosen to be equal to the lower triangular part of $A$, therefore the iteration matrix is given by $B = (D + L)^{-1}(D + L - A)$ and the iteration itself is $\B{x}^{(k+1)}=B\B{x}^{(k)}+(D+L)^{-1}\B{b}$ which can be written component-wise as
$$x_i^{(k+1)}=\frac{1}{a_{ii}}\left(b_i-\sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum_{j=i+1}^{N}a_{ij}x_j^{(k)}\right) \qtq{for all} i=1,\dots,N.$$ {#eq-GSmethod}

Contrary to Jacobi method, Gauss-Seidel method updates the components in sequential mode.

There are many other methods that use splitting like:

- Damped Jacobi method: $P=\frac{1}{\omega}D$ for some $\omega \neq 0$
- Successive over-relaxation method: $P=\frac{1}{\omega}D+L$ for some $\omega \neq 0$
- Symmetric successive over-relaxation method: $P=\frac{1}{\omega(2-\omega)}(D+\omega L) D^{-1} (D+\omega U)$ for some $\omega \neq 0,2.$

### Computational Cost & Stopping Criteria

There are essentially two factors contributing to the effectiveness of an iterative method for $A\B{x}=\B{b}$: the computational cost per iteration and the number of performed iterations.  The computational cost per iteration depends on the structure and sparsity of the original matrix $A$ and on the choice of the splitting.  For both Jacobi and Gauss-Seidel methods, without further assumptions on $A$, the computational cost per iteration is $\OO{N^2}$.  Iterations should be stopped when one or more stopping criteria are satisfied, as will be discussed below.  For both Jacobi and Gauss-Seidel methods, the cost of performing $k$ iterations is $\OO{kN^2}$; so as long as $k \ll N$, these methods are much cheaper than Gaussian elimination. 

In theory, iterative methods require an infinite number of iterations to converge to the exact solution of a linear system but in practice, aiming for the exact solution is neither reasonable nor necessary.  Indeed, what is actually needed is an approximation $\B{x}^{(k)}$ for which the error is guaranteed to be lower than a desired tolerance $\tau>0$.  On the other hand, since the error is itself unknown (as it depends on the exact solution), a suitable *a posteriori* error estimator is needed which predicts the error starting from quantities that have already been computed.  There are two natural estimators one may consider:

- **Residual**:  The residual error at the $\nth{k}$ iteration, denoted $\B{r}^{(k)}$ is given by the error between $A\B{x}^{(k)}$ and $\B{b}$, namely $\B{r}^{(k)}=\B{b}-A\B{x}^{(k)}$.  An iterative method can be stopped at the first iteration step $k=k_{\min}$ for which
$$\|\B{r}^{(k)}\|\leq\tau \|\B{b}\|.$$
- **Increment**:  The incremental error at the $k^{\mathrm{th}}$ iteration, denoted $\B{\delta}^{(k)}$ is the error between consecutive approximations, namely $\B{\delta}^{(k)}=\B{x}^{(k)}-\B{x}^{(k-1)}$.  An iterative method can be stopped after the first iteration step $k=k_{\min}$ for which
$$\|\B{\delta}^{(k)}\|\leq\tau.$$

Of course, another way to stop the iteration is by imposing a maximum number of allowable iterations $K$, this is usually a good starting point since it is not possible to know beforehand if the method does indeed converge.  Enforcing a maximum number of iterations will determine if the initial guess is suitable, if the method is suitable or indeed if there is any convergence.

## In-Built MATLAB Procedures

Given that MATLAB is well-suited to dealing with matrices, it has a very powerful method of solving linear systems and it is using the ***Backslash Operator***.  This is a powerful in-built method that can solve any square linear system regardless of its form.  MATLAB does this by first determining the general form of the matrix (sparse, triangular, Hermitian, etc.) before applying the appropriate optimised method.

For the linear system
$$A \B{x} = \B{b} \qtq{where} A \in \RR^{N \times N}, \quad \B{x} \in \RR^N, \quad \B{b} \in \RR^N$$
MATLAB can solve this using the syntax `x=A\b`.

:::{.callout-caution icon=false}
## Starting Example

Returning to the example in the beginning of this section, the matrix system was
$$\underbrace{\Mat{1 & 1 & 1 \\ 1 & -2 & 0 \\ 0 & 1 & -1}}_{A} \underbrace{\Mat{a \\ b \\ c}}_{\B{x}} = \underbrace{\Mat{20 \\ 0 \\ 10}}_{\B{b}}.$$
This can be solved as follows:
```matlab
>> A=[1,1,1;1,-2,0;0,1,-1];
>> b=[20;0;10];
>> A\b
ans =
     15.0000
      7.5000
     -2.5000
```
:::

:::{.callout-note}
The [MATLAB website](https://uk.mathworks.com/help/matlab/ref/double.mldivide.html) shows the following flowcharts for how `A\b` classifies the problem before solving it.

![If the matrix $A$ is full.](figures/mldivide_full.png)

![If the matrix $A$ is sparse.](figures/mldivide_sparse.png)
:::

## Exersises

:::{.callout-important icon=false}
## Exercise 2.1

Let $A$ and $B$ be invertible matrices, $p \in \mathbb{N}$ and $\lambda \in \mathbb{R}$.  The condition number $\kappa_p$ has the following properties:

i. $\kappa_p(A) \geq 1$;
ii. If $A$ is an orthogonal matrix ($A^{-1}=A^{\mathrm{T}}$), then $\kappa_2(A)=1$;
iii. $\kappa_2\nbr{\Tr{A}}=\kappa_2\nbr{A^{-1}}=\kappa_2(A)$;
iv. $\kappa_p(\lambda A)=\kappa_p(A)$;
v. $\kappa_p(AB) \leq \kappa_p(A)\kappa_p(B)$.

You may use the fact that $\| A \|_2=\| \Tr{A} \|_2$.

:::

:::{.callout-tip icon=false collapse=true}
## Solution 2.1

$$\kappa_p(A)=\Norm{A}{p} \Norm{A^{-1}}{p}$$

i. Using the submultiplicative property of matrices
$$\kappa_p(A)=\Norm{A}{p} \Norm{A^{-1}}{p} \geq \Norm{A A^{-1}}{p} = \Norm{\mathcal{I}}{p}=1.$$

ii.  If $A$ is orthogonal ($A^{-1}=\Tr{A}$), then the submultiplicative property of matrices becomes an equality, so
$$\kappa_2(A)=\Norm{A}{2} \Norm{A^{-1}}{2} = \Norm{A A^{-1}}{2} = \Norm{\mathcal{I}}{2}=1.$$

iii.

\begin{multline}
\bullet \; \kappa_2\nbr{\Tr{A}}=\Norm{\Tr{A}}{2}\Norm{\Tr{\nbr{A^{-1}}}}{2}=\Norm{\Tr{A}}{2}\Norm{\Tr{A^{-1}}}{2} \\ =\Norm{A}{2}\Norm{A^{-1}}{2}=\kappa_2(A).
\end{multline}
$$\bullet \; \kappa_2\nbr{A^{-1}}=\Norm{A^{-1}}{2}=\Norm{\nbr{A^{-1}}^{-1}}{2}=\Norm{A}{2}\Norm{A^{-1}}{2}=\kappa_2(A).$$

iv.

\begin{multline}
\kappa_p(\lambda A)=\Norm{\lambda A}{p} \Norm{(\lambda A)^{-1}}{p}=\Norm{\lambda A}{p} \Norm{\frac{1}{\lambda}A^{-1}}{p}= \\ |\lambda| \Norm{A}{p} \frac{1}{|\lambda|}\Norm{A^{-1}}{p}=\Norm{A}{p} \Norm{A^{-1}}{p}=\kappa_p(A).
\end{multline}

v.

\begin{multline}
\kappa_p(AB)=\Norm{AB}{p} \Norm{(AB)^{-1}}{p}=\Norm{AB}{p} \Norm{A^{-1} B^{-1}}{p} \\ \leq \Norm{A}{p} \Norm{B}{p} \Norm{B^{-1}}{p} \Norm{A^{-1}}{p}=\kappa_p(A)\kappa_p(B).
\end{multline}

:::

:::{.callout-important icon=false}
## Exercise 2.2

Solve the following linear systems of the form $A \B{x}=\B{b}$ using the following direct methods:

i. Direct substitution
$$A=\Mat{1 & 0 & 0 \\ 0 & -2 & 0 \\ 0 & 0 & 5}, \quad \B{b}=\Mat{3 \\ 9 \\ 0}$$

ii. Backward substitution
$$A=\Mat{4 & 2 & 1 \\ 0 & 2 & 1 \\ 0 & 0 & 10}, \quad \B{b}=\Mat{1 \\ 1 \\ 1}$$

iii. Forwards substitution
$$A=\Mat{1 & 0 & 0 \\ 4 & 5 & 0 \\ 9 & 1 & 2}, \quad \B{b}=\Mat{0 \\ 0 \\ 1}$$

iv. TDMA
$$A=\Mat{2 & -1 & 0 & 0 & 0 \\ -1 & 2 & -1 & 0 & 0 \\ 0 & -1 & 2 & -1 & 0 \\ 0 & 0 & -1 & 2 & -1 \\ 0 & 0 & 0 & -1 & 2}, \quad \B{b}=\Mat{1 \\ 0 \\ 1 \\ 0 \\ 1}$$

vi. Cramer's Rule
$$A=\Mat{1 & 0 & 2 \\ 2 & 1 & 2 \\ -1 & 0 & 0}, \quad \B{b}=\Mat{12 \\ 0 \\ 6}$$
:::

:::{.callout-tip icon=false}
## Solutions 2.2

$$\mathrm{i.} \quad \B{x}=\Mat{3 \\ -4.5 \\ 0}$$

$$\mathrm{ii.} \quad \B{x}=\Mat{0 \\ 0.45 \\ 0.1}$$

$$\mathrm{iii.} \quad \B{x}=\Mat{0 \\ 0 \\ 0.5}$$

$$\mathrm{iv.} \quad \B{x}=\Mat{1.5 \\ 2 \\ 2.5 \\ 2 \\ 1.5}$$

$$\mathrm{v.} \quad \B{x}=\Mat{0 \\ -12 \\ 6}$$
:::

:::{.callout-important icon=false}
## Exersise 2.3

Using the formulas derived, write MATLAB codes that can perform:

- Direct substitution
- Backward substitution
- Forward substitution
- TDMA
- Cramer's Rule

Use the examples in Exercise 2.2 as test cases.

:::

:::{.callout-tip icon=false collapse=true}
## Solutions 2.3

Direct Substitution

```matlab
function D_Sub

A=diag([1,-2,5]);
b=[3;9;0];

if isdiag(A)~=1
    error('A must be a diagonal matrix')
end

if any(diag(A)==0)
    error('All diagonal terms must be non-zero')
end

N=length(b);

x=zeros(1,N);

for n=1:1:N
    x(n)=b(n)/A(n,n);
end

disp('x=')
disp(x)

end
```

Backward Substitution

```matlab
function B_Sub

A=[4,2,1;0,2,1;0,0,10];
b=[1;1;1];

if istriu(A)~=1
    error('A must be an upper triangluar matrix')
end

if any(diag(A)==0)
    error('All diagonal terms must be non-zero')
end

N=length(b);

x=zeros(1,N);

x(N)=b(N)/A(N,N);

for n=N-1:-1:1
    S=0;
    for i=n+1:1:N
        S=S+A(n,i)*x(i);
    end
    x(n)=(b(n)-S)/A(n,n);
end

disp('x=')
disp(x)

end
```

Forward Substitution

```matlab
function F_Sub

A=[1,0,0;4,5,0;9,1,2];
b=[0;0;1];

if istril(A)~=1
    error('A must be a lower triangular matrix')
end

if any(diag(A)==0)
    error('All diagonal terms must be non-zero')
end

N=length(b);

x=zeros(1,N);

x(1)=b(1)/A(1,1);

for n=2:1:N
    S=0;
    for i=1:1:n-1
        S=S+A(n,i)*x(i);
    end
    x(n)=(b(n)-S)/A(n,n);
end

disp('x=')
disp(x)

end
```

TDMA

```matlab
function TDMA

m=[2,2,2,2,2];
l=[-1,-1,-1,-1];
r=[-1,-1,-1,-1];
A=diag(m)+diag(l,-1)+diag(r,1);

b=[1;0;1;0;1];

N=length(b);

R=zeros(1,N);
B=zeros(1,N);
x=zeros(1,N);

l=[0,l];
r=[r,0];

R(1)=r(1)/m(1);
for n=2:1:N-1
    R(n)=r(n)/(m(n)-l(n)*R(n-1));
end

B(1)=b(1)/m(1);
for n=2:1:N
    B(n)=(b(n)-l(n)*B(n-1))/(m(n)-l(n)*R(n-1));
end

x(N)=B(N);
for n=N-1:-1:1
    x(n)=B(n)-R(n)*x(n+1);
end

disp('x=')
disp(x)

end
```

Cramer's Rule

```matlab
function Cramer

A=[1,0,2;2,1,2;-1,0,1];
b=[12;0;6];

N=length(b);

d=det(A);

x=zeros(N,1);

for n=1:1:N
    AA=A;
    AA(:,n)=b;
    x(n)=det(AA)/d;
end

disp('x=')
disp(x)

end
```

:::